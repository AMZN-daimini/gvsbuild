From d0ef6399d4c8f19621d6cfd1c6f3ef04b207a10a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=D0=A0=D1=83=D1=81=D0=BB=D0=B0=D0=BD=20=D0=98=D0=B6=D0=B1?=
 =?UTF-8?q?=D1=83=D0=BB=D0=B0=D1=82=D0=BE=D0=B2?= <lrn1986@gmail.com>
Date: Sat, 31 Jul 2021 11:01:06 +0000
Subject: [PATCH 3/5] GWin32AppInfo: re-trigger registry watcher from the
 callback

To ensure that the watch is properly re-set every time, call
watch_keys() from the watch callback. Previously the watch was only
renewed after a data update was done in a worker thread, which made
no sense, since the update function was implemented in such a way
that it can (and should) be re-triggered on each key change, until
the changes stop coming, and that can only happen if we renew
the registry watcher right away.
---
 gio/gwin32appinfo.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 5403225e2..4074f402c 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -3828,6 +3828,9 @@ update_registry_data (void)
   return;
 }
 
+static void
+watch_keys (void);
+
 /* This function is called when any of our registry watchers detect
  * changes in the registry.
  */
@@ -3835,6 +3838,7 @@ static void
 keys_updated (GWin32RegistryKey  *key,
               gpointer            user_data)
 {
+  watch_keys ();
   /* Indicate the tree as not up-to-date, push a new job for the AppInfo thread */
   g_atomic_int_inc (&gio_win32_appinfo_update_counter);
   /* We don't use the data pointer, but it must be non-NULL */
@@ -4029,7 +4033,6 @@ gio_win32_appinfo_init (gboolean do_wait)
       g_mutex_lock (&gio_win32_appinfo_mutex);
       while (g_atomic_int_get (&gio_win32_appinfo_update_counter) > 0)
         g_cond_wait (&gio_win32_appinfo_cond, &gio_win32_appinfo_mutex);
-      watch_keys ();
       g_mutex_unlock (&gio_win32_appinfo_mutex);
     }
 }
-- 
2.17.1

